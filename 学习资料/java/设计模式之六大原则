23种设计模式
1.对象创建型模式：抽象了对象实例化的过程,用来帮助创建对象的实例
工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
2.结构性模式：描述如何组合类和对象以获得更大的结构
适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
3.行为型模式：描述算法和对象间职责的分配
策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。



参考：http://www.cnblogs.com/dolphin0520/p/3919839.html
一、单一职责原则
单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。
一个类只负责一个功能领域中的相应职责，就一个类而言，应该只有一个引起它变化的原因。
单一职责原则是实现高内聚、低耦合的指导方针
二、开闭原则
对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。
为了满足开闭原则，需要对系统进行抽象化设计。
可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，
可以通过它们定义系统的抽象层，再通过具体类来进行扩展。
三、里氏替换原则
所有引用基类（父类）的地方必须能透明地使用其子类的对象。
在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。
例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物。
由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。
在使用里氏代换原则时需要注意如下几个问题：
(1)子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。
根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，
则无法在以父类定义的对象中使用该方法。
(2) 我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，
子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。

里氏代换原则是开闭原则的具体实现手段之一。

四、依赖倒置原则
抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对抽象(抽象类或者接口)编程，而不是针对实现编程。
依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。
在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，
依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。
常用的注入方式有三种:构造注入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。

五、接口隔离原则
使用多个隔离的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。
根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。

六、迪米特法则（最少知道原则）
一个软件实体应当尽可能少地与其他实体发生相互作用，使得系统功能模块相对独立。
迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，
如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。

合成复用原则（Composite Reuse Principle）
尽量首先使用合成/聚合的方式，而不是使用继承。

