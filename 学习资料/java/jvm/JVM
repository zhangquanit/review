
一、JVM特性？
平台无关性.
Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。
一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。
而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。
Java语言使用模式Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），
就可以在多种平台上不加修改地运行。Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。

二、简述堆和栈的区别
JVM 中堆和栈属于不同的内存区域，使用目的也不同。
栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。

四、简述JVM内存分配
基本数据类型的变量和对象的引用都是在栈分配的
堆内存用来存放由new创建的对象和数组
静态变量，程序在一加载的时候就在堆中为静态变量分配内存，堆中的内存地址存放在栈中
实例变量：当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量，是根据零散的堆内存地址，
    通过哈希算法换算为一长串数字以表征这个变量在堆中的”物理位置”,实例变量的生命周期–当实例变量的引用丢失后，
    将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存
局部变量: 由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放


你知道哪些垃圾回收算法?
垃圾回收从理论上非常容易理解,具体的方法有以下几种:
更详细的内容参见 http://blog.csdn.net/dd864140130/article/details/50084471
1. 标记-清除
算法分为两个过程：
1)、标记正所有需要回收的对象 2)、标记完成后清除被标记的对象。其标记的过程就是判断对象有效性，执行可达性分析的过程.
缺点：
1、每次进行垃圾回收时，会暂停当前用户程序的运行（类似让所有的同学站起来）
2、垃圾回收器需要间隔性的检查，并且标记和清除的过程相对较慢。
3、在标记清除之后可能会产生大量内存碎片，导致一旦需要为大对象分配空间时，由于找不到足够大的内存空间，而不得以引发另外一次GC过程。

2. 复制法
它将可用内存划分为两个等量的区域（使用区和空闲区），每次只使用一块。
当正在使用的区域需要进行垃圾回收时，存活的对象将被复制到另外一块区域。原先被使用的区域被重置，转为空闲区。
缺点：
1、原有可用空间被缩小为1/2，空间利用率降低了。
2、过程中也会暂停当前应用的运行。

3. 标记-整理
复制算法在对象存活率较高的情况下就要进行较多的复制操作，更重要的是该算法浪费一半的内存空间，
为了解决该问题，出现了标记—整理算法：其标记的过程和“标记-清除”算法一样，而整理的过程则是让所有存活的对象都向另外一端移动，然后直接清理掉端边界以外的内存。
(也就是让存活的对象都聚在一起，把边界不使用的内存回收掉)
缺点：
1、暂停当前应用的运行，非实时性的回收。

4. 分代回收
对象的生存周期总体可分为三种：新生代、老年代和永久代。因此可以根据各个年代的特点采用适当的垃圾回收算法。
新生代由于大部分对象的生存时间都较短，可以采用复制法，老年代和永久代可采用标记整理法。

5.增量收集算法
以上所述的算法，都存在一个缺点：在进行垃圾回收时需要暂停当前应用的执行，也就是这时候的垃圾回收线程不能和应用线程同时运行。

如何判断一个对象是否应该被回收？
这就是所谓的对象存活性判断,常用的方法有两种:
1）引用计数法;
2）对象可达性分析.由于引用计数法存在互相引用导致无法进行GC的问题,所以目前JVM虚拟机多使用对象可达性分析算法.

简单的解释一下垃圾回收？
Java 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。
一般的实现是划分成3个世代：年轻、年老和永久。
内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。
对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。
一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性.

调用System.gc()会发生什么?
通知GC开始工作,但是GC真正开始的时间不确定.
